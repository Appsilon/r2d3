'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.css = css;
exports.addClass = addClass;
exports.containsClass = containsClass;
exports.removeClass = removeClass;
exports.toggleClass = toggleClass;

var _djsfy = require('./djsfy');

var _djsfy2 = _interopRequireDefault(_djsfy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Edge / IE
var MS = 'ms';
// Chrome / Safari
var WEBKIT = 'webkit';
// Firefox
var MOZ = 'moz';
// Opera
var O = 'o';
var XV = 'xv';
// KDE
var KHTML = 'khtml';

var PREFIXIES = [MS, WEBKIT, MOZ, O, XV, KHTML];

var CSS_PREFIXED = {
  float: 'cssFloat'
};

function css(node, cssStyles) {
  if (!node || node.nodeType === 8 || node.nodeType === 3 || !node.style) {
    return null;
  }

  for (var key in cssStyles) {
    if (Object.hasOwnProperty.call(cssStyles, key)) {
      var keyPrefixed = getStyleWithPrefixKey({
        styleList: node.style,
        styleToCheck: key
      });

      if (keyPrefixed) {
        node.style[keyPrefixed] = cssStyles[key];
      }
    }
  }

  return (0, _djsfy2.default)(node);
}

function addClass(node, classList) {
  var currentClassList = node.getAttribute('class') || '';

  classList = parseArray(classList) || [];

  if (classList instanceof Array) {
    for (var i = 0, length = classList.length; i < length; i++) {
      if (!classList[i].trim()) {
        throw new SyntaxError('djs.addClass(): Empty strings are not valid class name');
      }

      if (!containsClassIntoList(currentClassList, classList[i])) {
        currentClassList += ' ' + classList[i].trim();
      }
    }
  }

  node.setAttribute('class', currentClassList.trim());

  return (0, _djsfy2.default)(node);
}

function containsClass(node, className) {
  if (!node) {
    throw new Error('The element must be not empty.');
  }

  assertClassName(className);

  return containsClassIntoList(node.getAttribute('class'), className);
}

function removeClass(node, classToRemove) {
  var currentClassList = getCurrentClassList(node);

  classToRemove = parseArray(classToRemove) || [];

  if (!currentClassList.length || !classToRemove.length) {
    return (0, _djsfy2.default)(node);
  }

  if (classToRemove instanceof Array) {
    classToRemoveInteraction: for (var i = 0, length = classToRemove.length; i < length; i++) {
      var className = classToRemove[i];
      assertClassName(className);

      currentClassListInteraction: for (var y = 0, _length = currentClassList.length; y < _length; y++) {
        if (className === currentClassList[y]) {
          currentClassList.splice(y, 1);
          continue classToRemoveInteraction;
        }
      }
    }
  }

  node.setAttribute('class', currentClassList.join(' '));

  return (0, _djsfy2.default)(node);
}

function toggleClass(node, className, force) {
  if (!node) {
    throw new Error('The element must be not empty.');
  }

  assertClassName(className);

  var currentClassList = getCurrentClassList(node);

  if (containsClassIntoList(currentClassList, className)) {
    if (!force) {
      removeClass(node, className);
    }
  } else {
    if (force !== false) {
      addClass(node, className);
    }
  }

  return (0, _djsfy2.default)(node);
}

function getCurrentClassList(node) {
  return parseArray(node.getAttribute('class')) || [];
}

function assertClassName(className) {
  if (!className) {
    throw new Error('The className provided (\'' + className + '\') must be not empty.');
  }

  if (containsWhitespaces(className)) {
    throw new Error('The className provided (\'' + className + '\') contains HTML space characters, which are not valid.');
  }
}

function containsWhitespaces(string) {
  return string.match(/\s/);
}

function containsClassIntoList(classList, classToCheck) {
  classList = parseArray(classList) || [];

  for (var i = 0, length = classList.length; i < length; i++) {
    if (classList[i].trim() === classToCheck.trim()) {
      return true;
    }
  }

  return false;
}

function parseArray(classList) {
  if (typeof classList === 'string') {
    classList = classList.split(' ');
  }

  return classList;
}

function getStyleWithPrefixKey(_ref) {
  var styleList = _ref.styleList;
  var styleToCheck = _ref.styleToCheck;

  if (styleToCheck in styleList) {
    return styleToCheck;
  }

  if (styleToCheck in CSS_PREFIXED) {
    return CSS_PREFIXED[styleToCheck];
  }

  for (var i = 0, length = PREFIXIES.length; i < length; i++) {
    var styleWithPrefix = '' + PREFIXIES[i] + styleToCheck[0].toUpperCase() + styleToCheck.substring(1);

    if (styleWithPrefix in styleList) {
      CSS_PREFIXED[styleToCheck] = styleWithPrefix;
      return CSS_PREFIXED[styleToCheck];
    }
  }

  return false;
}